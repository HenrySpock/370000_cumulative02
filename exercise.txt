******************
PART 1 Commit 1: 
******************

// Import the sqlForPartialUpdate function from the sql.js module
const { sqlForPartialUpdate } = require("./sql");

******************
PART 1 Commit 2:
******************
// Start test suite for the sqlForPartialUpdate function
describe("sqlForPartialUpdate", function () {

  // Test the function with data
  test("works with data", function () {
    // Call the sqlForPartialUpdate function with sample data
    const result = sqlForPartialUpdate(
      { firstName: "Douglas", age: 42 },
      { firstName: "first_name" }
    );
    // Expect the result to match a specific format
    expect(result).toEqual({
      setCols: '"first_name"=$1, "age"=$2',
      values: ["Douglas", 42],
    });
  });

  // Test the function with no data - should throw an error
  test("throws error if no data", function () {
    // Call the sqlForPartialUpdate function with empty objects
    // expect error to be thrown with specific message
    expect(() => sqlForPartialUpdate({}, {})).toThrowError(
      "No data"
    );
  });
});

Documentation:
sql.test.js tests the sqlForPartialUpdate function from the helpers/sql.js module. The function takes two objects as arguments: 
a data object with the values to be updated, and a js-to-sql object mapping names of the columns to the names in the database. 
It returns an object with two properties: setCols (a string with column names and corresponding update parameter placeholders)
and values (an array of values for the update statement to use).

'Test the function with data' checks the function with sample data. It expects the resulting format to match.

"Test the function with no data' checks the function with no data and exepcts an error ("No data").

******************
Part 2 Commit 3:
****************** 
Add filtering to GET /companies router.get (with comments):
router.get('/', async function (req, res, next) {
  try { 
    if (!validateQuery(req.query)) {
      return res.status(400).json({ error: 'Invalid query parameters' });
    }

    const filters = {
      name: req.query.name || null,
      minEmployees: req.query.minEmployees || null,
      maxEmployees: req.query.maxEmployees || null,
    };
    
    const whereClauses = [];
    const params = [];

    if (filters.name) {
      whereClauses.push(`LOWER(name) LIKE LOWER($${params.length + 1})`);
      params.push(`%${filters.name}%`);
    }

    if (filters.minEmployees) {
      whereClauses.push(`num_employees >= $${params.length + 1}`);
      params.push(filters.minEmployees);
    }

    if (filters.maxEmployees) {
      whereClauses.push(`num_employees <= $${params.length + 1}`);
      params.push(filters.maxEmployees);
    }
    console.log("FILTERS: ", filters)
    const whereStr = whereClauses.length > 0 ? `WHERE ${whereClauses.join(' AND ')}` : '';
    const queryStr = `SELECT * FROM companies ${whereStr}`;

    // Execute the query using your preferred database library.
    const companies = await Company.findAll({
      name: filters.name,
      minEmployees: filters.minEmployees,
      maxEmployees: filters.maxEmployees,
    });

    return res.json({ companies });

  } catch (err) {
    return next(err);
  }
});

******************
Part 2 Commit 4:
****************** 
Adding the validateQuery function referenced by companies router.get:
// validateQuery checks if the provided query object contains only the allowed fields
function validateQuery(query) {
  const allowedFields = new Set(['name', 'minEmployees', 'maxEmployees']);
  const queryFields = Object.keys(query);

  for (const field of queryFields) {
    if (!allowedFields.has(field)) {
      return false;
    }
  }
  console.log("FILTERS VALDIATED")
  return true;
}

******************
Part 2 Commit 5:
****************** 
Documentation:
GET /companies
Description: Fetches a list of companies from the database, filtered based on the provided query parameters.
Query Parameters:

name: (optional) Filter companies by name (case-insensitive, partial match).
minEmployees: (optional) Filter companies with a minimum number of employees.
maxEmployees: (optional) Filter companies with a maximum number of employees.
Example Usage:

Fetch all companies with a name containing "smith" and between 410 and 990 employees:
GET /companies?name=smith&minEmployees=410&maxEmployees=990
validateQuery(query)
Description: Validates the incoming query parameters against the allowed fields.
Parameters:

query: The query object containing the query parameters
Returns: Returns true if all query parameters are valid, false otherwise.

Company.findAll({ name, minEmployees, maxEmployees })
Description: A static method in the Company model that fetches companies from the database based on the provided filters.
Parameters:

name: (optional) Filter companies by name (case-insensitive, partial match).
minEmployees: (optional) Filter companies with a minimum number of employees.
maxEmployees: (optional) Filter companies with a maximum number of employees.
Returns: An array of company objects that match the provided filters. Each object contains the following properties:

handle: Company handle
name: Company name
num_employees: Number of employees
description: Company description
logo_url: Company logo URL

******************
Part 2 Commit 6:
****************** 
curl tets for company filtering:
Filter by name:
curl "http://localhost:3001/companies?name=smith" | jq

Filter by minEmployees:
curl "http://localhost:3001/companies?minEmployees=990" | jq

Filter by maxEmployees:
curl "http://localhost:3001/companies?maxEmployees=20" | jq

Filter by name and minEmployees:
curl "http://localhost:3001/companies?name=smith&minEmployees=400" | jq

Filter by name and maxEmployees:
curl "http://localhost:3001/companies?name=smith&minEmployees=5000" | jq

Filter by minEmployees and maxEmployees:
curl "http://localhost:3001/companies?minEmployees=400&maxEmployees=420" | jq

Filter by name, minEmployees, and maxEmployees:
curl "http://localhost:3001/companies?name=Apple&minEmployees=5000&maxEmployees=10000" | jq

******************
Part 3 Commit 7:
****************** 
Register a user:
curl -X POST "http://localhost:3001/auth/register" -H "Content-Type: application/json" -d '{"username": "11111", "password": "11111", "firstName": "11111", "lastName": "11111", "email": "11111@11111.com"}'
{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IjExMTExIiwiaXNBZG1pbiI6ZmFsc2UsImlhdCI6MTY4MjY2MTk4MH0.jFXnKT3FbVhcxTZFRHn8s-zYh-C-vn86i49Whttq22Y"}

Test authentication against a route that uses ensureLoggedIn function:
Without and with token:
without
curl -X GET "http://localhost:3001/users" -H "Content-Type: application/json"
with
curl -X GET "http://localhost:3001/users" -H "Content-Type: application/json" -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IjExMTExIiwiaXNBZG1pbiI6ZmFsc2UsImlhdCI6MTY4MjY2MTk4MH0.jFXnKT3FbVhcxTZFRHn8s-zYh-C-vn86i49Whttq22Y"

Update the new user to admin:
UPDATE users SET is_admin = true WHERE username = '11111';

Create a second user:
curl -X POST "http://localhost:3001/auth/register" -H "Content-Type: application/json" -d '{"username": "22222", "password": "22222", "firstName": "22222", "lastName": "22222", "email": "22222@22222.com"}'
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IjIyMjIyIiwiaXNBZG1pbiI6ZmFsc2UsImlhdCI6MTY4MjY2NDMzMn0.IaIJ3peHOOJKlMpbNhZ6GtIR7uWJIaip0RaFYh4cp8w

******************
Part 3 Commit 8:
****************** 
Create a login route that check sfor admin status:
In auth.js:
/** POST /auth/login:  { username, password } => { token }
 *
 * Returns JWT token which can be used to authenticate further requests.
 *
 * Authorization required: none
 */

router.post("/login", async function (req, res, next) {
  try {
    const { username, password } = req.body;
    const user = await User.authenticate(username, password);
    const token = createToken(user);

    // Log the token payload to the terminal
    console.log('Token payload:', user);
    
    return res.json({ token });
  } catch (err) {
    return next(err);
  }
});

Testing login route:
curl -X POST "http://localhost:3001/auth/login" -H "Content-Type: application/json" -d '{"username": "11111", "password": "11111"}'
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IjExMTExIiwiaXNBZG1pbiI6dHJ1ZSwiaWF0IjoxNjgyNjY0NTM4fQ.aEPPwspykwM3_oCagXaihmCSmvVJUlL8IPvjTHSh7wk
curl -X POST "http://localhost:3001/auth/login" -H "Content-Type: application/json" -d '{"username": "22222", "password": "22222"}'
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IjIyMjIyIiwiaXNBZG1pbiI6ZmFsc2UsImlhdCI6MTY4MjY2NTU4NH0.cOAuCfIR0CBUIcG-t3uGdFCeNlprtCKzzWkXkCfDGPc
curl -X POST "http://localhost:3001/auth/login" -H "Content-Type: application/json" -d '{"username": "33333", "password": "33333"}'

******************
Part 3 Commit 9:
****************** 
Function for checking admin status in middleware/auth.js :
/** Middleware: Ensure user is an admin.
 *
 * If a token was provided and the user is logged in, checks if the user has
 * the isAdmin flag set to true in the token payload (res.locals.user.isAdmin).
 *
 * If the user is not an admin, raises Unauthorized.
 *
 * Requires the authenticateJWT middleware to be executed before this middleware.
 */

function ensureAdmin(req, res, next) {
  try {
    if (!res.locals.user || !res.locals.user.isAdmin) {
      throw new UnauthorizedError("Admin privileges required");
    }
    return next();
  } catch (err) {
    return next(err);
  }
}
 
Export ensureAdmin:
module.exports = {
  authenticateJWT,
  ensureLoggedIn,
  ensureAdmin,
};

******************
Part 3 Commit 10:
****************** 
Update routes/companies.js and routes/users.js to include authenticateJWT and ensureAdmin:
const { ensureLoggedIn, authenticateJWT, ensureAdmin } = require("../middleware/auth");

Update the relevant routes to include ensureLoggedIn, authenticateJWT, ensureAdmin functions:
POST route for routes/companies.js:
/** POST / { company } =>  { company }...

router.post("/", ensureLoggedIn, authenticateJWT, ensureAdmin, async function (req, res, next)...

If curled with user 22222's token:
curl -X POST "http://localhost:3001/companies" \
     -H "Content-Type: application/json" \
     -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IjExMTExIiwiaXNBZG1pbiI6dHJ1ZSwiaWF0IjoxNjgyNjY0NTM4fQ.aEPPwspykwM3_oCagXaihmCSmvVJUlL8IPvjTHSh7wk" \
     -d '{"handle": "55555", "name": "55555", "description": "55555 5", "numEmployees": 55, "logoUrl": "https://example.com/logo.png"}'

{"error":{"message":"Admin privileges required","status":401}}

But if curled with user 11111's token, we create the new company.

PATCH route for routes/companies.js:
/** PATCH /[handle] { fld1, fld2, ... } => { company }...

router.patch("/:handle", ensureLoggedIn, authenticateJWT, ensureAdmin, async function (req, res, next)...

Curling this with token from user 11111:
curl -X PATCH "http://localhost:3001/companies/55555" \
     -H "Content-Type: application/json" \
     -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IjExMTExIiwiaXNBZG1pbiI6dHJ1ZSwiaWF0IjoxNjgyNjY0NTM4fQ.aEPPwspykwM3_oCagXaihmCSmvVJUlL8IPvjTHSh7wk" \
     -d '{"name": "5---5", "description": "5---5"}'

DELETE route for routes/companies.js:
/** DELETE /[handle]  =>  { deleted: handle }...

router.delete("/:handle", ensureLoggedIn, authenticateJWT, ensureAdmin, async function (req, res, next) {

Curl the DELETE route with user 11111's token:
curl -X DELETE "http://localhost:3001/companies/55555" \
     -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IjExMTExIiwiaXNBZG1pbiI6dHJ1ZSwiaWF0IjoxNjgyNjY0NTM4fQ.aEPPwspykwM3_oCagXaihmCSmvVJUlL8IPvjTHSh7wk"
Company is deleted.

******************
Part 3 Commit 11:
****************** 
Updating _testCommon.js:
npx jest companies.test.js -i --coverage --watchAll=false
We are going to make u1Token an admin, create u2Token as not admin, and export u2Token:
const u1Token = createToken({ username: "u1", isAdmin: true });
const u2Token = createToken({ username: "u2", isAdmin: false });

module.exports = {
  commonBeforeAll,
  commonBeforeEach,
  commonAfterEach,
  commonAfterAll,
  u1Token,
  u2Token,
};

Updateing companies.test.js:
const {
  commonBeforeAll,
  commonBeforeEach,
  commonAfterEach,
  commonAfterAll,
  u1Token,
  u2Token,
} = require("./_testCommon");

/************************************** GET /companies */

describe("GET /companies", function () {
  test("ok for anon", async function () {
    const resp = await request(app).get("/companies");
    expect(resp.body).toEqual({
      companies:
          [
            {
              handle: "c1",
              name: "C1",
              description: "Desc1",
              num_employees: 1,
              logo_url: "http://c1.img",
            },
            {
              handle: "c2",
              name: "C2",
              description: "Desc2",
              num_employees: 2,
              logo_url: "http://c2.img",
            },
            {
              handle: "c3",
              name: "C3",
              description: "Desc3",
              num_employees: 3,
              logo_url: "http://c3.img",
            },
          ],
    });
  });
});

******************
Part 3 Commit 12:
****************** 
GET /companies/:handle:
Update the findAll parameters to include handle:
static async findAll(searchParams = {}) {
  const { name, minEmployees, maxEmployees, handle } = searchParams;
...
  if (handle) {
    queryValues.push(handle);
    whereClause.push(`handle = $${queryValues.length}`);
  }
...

Update the route function call:
    const companies = await Company.findAll({ handle: req.params.handle });

PATCH: All pass.
DELETE: All pass - adding a test for a user trying to delete a company:
  test("unauth for anon", async function () {
    const resp = await request(app)
        .delete(`/companies/c1`);
    expect(resp.statusCode).toEqual(401);
  });

******************
Part 3 Commit 13:
****************** 
Running all test suites, 4 new failures are occuring in users.test.js. I assume this is 
because u1Token is now an admin.

In GET /users:
update the expected response:
        {
          username: "u1",
          firstName: "U1F",
          lastName: "U1L",
          email: "user1@user.com",
          isAdmin: true,
        },

In GET /users/username:
update the expected response:
      user: {
        username: "u1",
        firstName: "U1F",
        lastName: "U1L",
        email: "user1@user.com",
        isAdmin: true,
      },

In PATCH /users/:username:
  test("works for users", async function () {

update the expected response: 
      user: {
        username: "u1",
        firstName: "New",
        lastName: "U1L",
        email: "user1@user.com",
        isAdmin: true,
      },

 test("works: set new password", async function () {
update the expected response: 
      user: {
        username: "u1",
        firstName: "New",
        lastName: "U1L",
        email: "user1@user.com",
        isAdmin: true,
      },

******************
Part 3 Commit 14:
****************** 
Update the USER routes that should only be accessible by admins:
Creating a user:
/** POST / { user }  => { user, token } 
update route functions:
router.post("/", ensureLoggedIn, authenticateJWT, ensureAdmin, async function (req, res, next) 

Curling with 22222:
curl -X POST -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IjIyMjIyIiwiaXNBZG1pbiI6ZmFsc2UsImlhdCI6MTY4MjY2NTU4NH0.cOAuCfIR0CBUIcG-t3uGdFCeNlprtCKzzWkXkCfDGPc" -H "Content-Type: application/json" -d '{"username":"66666", "password":"66666", "firstName":"66666", "lastName":"66666", "email":"66666@66666.com", "isAdmin":true}' http://localhost:3001/users
Response:
{"error":{"message":"Admin privileges required","status":401}}

Curling with 11111's token:
curl -X POST -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IjExMTExIiwiaXNBZG1pbiI6dHJ1ZSwiaWF0IjoxNjgzMDIzNTQ0fQ.fSjsfeAuYNWshYi93AA94oVUVdShzm_eVIXcIMZlu4Q" -H "Content-Type: application/json" -d '{"username":"77777", "password":"77777", "firstName":"77777", "lastName":"77777", "email":"77777@77777.com", "isAdmin":true}' http://localhost:3001/users

{"user":{"username":"77777","firstName":"77777","lastName":"77777","email":"77777@77777.com","isAdmin":true},"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Ijc3Nzc3IiwiaXNBZG1pbiI6dHJ1ZSwiaWF0IjoxNjgzMDIzNTc1fQ.RvNRuRT_skmbF3yu3NClGYs99yUc0XnxerW2MjxWwS0"}

Get list of all users:
/** GET / => { users: [ {username, firstName, lastName, email }, ... ] } 
Update the route parametes:

router.get("/", ensureLoggedIn, authenticateJWT, ensureAdmin, async function (req, res, next) {
  try {
    const users = await User.findAll();
    return res.json({ users });
  } catch (err) {
    return next(err);
  }
});

Curling with 22222:
curl -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IjIyMjIyIiwiaXNBZG1pbiI6ZmFsc2UsImlhdCI6MTY4MjY2NTU4NH0.cOAuCfIR0CBUIcG-t3uGdFCeNlprtCKzzWkXkCfDGPc" http://localhost:3001/users

Response:
{"error":{"message":"Admin privileges required","status":401}}

Curling with 11111:
curl -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IjExMTExIiwiaXNBZG1pbiI6dHJ1ZSwiaWF0IjoxNjgyNjY0NTM4fQ.aEPPwspykwM3_oCagXaihmCSmvVJUlL8IPvjTHSh7wk" http://localhost:3001/users | jq
Response:
Expected list of users
 
/** PATCH /[username] { user } => { user }
/** DELETE /[username]  =>  { deleted: username }
Should all require authenticateJWT and ensureAdmin:
router.patch("/:username", ensureLoggedIn, authenticateJWT, ensureAdmin, async function (req, res, next) {
router.delete("/:username", ensureLoggedIn, authenticateJWT, ensureAdmin, async function (req, res, next) {

******************
Part 3 Commit 15:
****************** 
Tests:
In all of these updates, note u1Token is already set to admin in _testCommon.js - changing this to u2Token makes the test fail

update:
  test("works for users: create admin", async function () {
to
  test("works for admins: create admin", async function () {

update:
describe("GET /users", function () {
to
describe("Works for admins: GET /users", function () { 

update:
describe("PATCH /users/:username", () => {
  test("works for users", async function () {
to
describe("PATCH /users/:username", () => {
  test("works for admins", async function () {

update:
describe("DELETE /users/:username", function () {
  test("works for users", async function () {
to
describe("DELETE /users/:username", function () {
  test("works for admins", async function () {

******************
Part 4 Commit 16:
****************** 
Write models/job.js:
"use strict";

const db = require("../db");
const { BadRequestError, NotFoundError } = require("../expressError");
const { sqlForPartialUpdate } = require("../helpers/sql");

/** Related functions for jobs. */

class Job {
  /** Create a job (from data), update db, return new job data.
   *
   * data should be { title, salary, equity, companyHandle }
   *
   * Returns { id, title, salary, equity, companyHandle }
   *
   * Throws BadRequestError if companyHandle is not in db.
   **/

  static async create({ title, salary, equity, companyHandle }) {
    const companyCheck = await db.query(
      `SELECT handle
           FROM companies
           WHERE handle = $1`,
      [companyHandle]);
  
    if (!companyCheck.rows[0])
      throw new BadRequestError(`Company ${companyHandle} not found.`);
   
    const result = await db.query(
      `INSERT INTO jobs
           (title, salary, equity, company_handle)
           VALUES ($1, $2, $3, $4)
           RETURNING id, title, salary, equity, company_handle AS "companyHandle"`,
      [
        title,
        salary,
        equity, 
        companyHandle,
      ],
    );
    const job = result.rows[0];
  
    return job;
  }
  

  /** Find all jobs.
   *
   * Returns [{ id, title, salary, equity, companyHandle }, ...]
   * */
  static async findAll(searchParams = {}) {
    const { title, minSalary, hasEquity } = searchParams;

    let whereClause = [];
    let queryValues = [];

    if (title) {
      queryValues.push(`%${title}%`);
      whereClause.push(`title ILIKE $${queryValues.length}`);
    }

    if (minSalary) {
      queryValues.push(minSalary);
      whereClause.push(`salary >= $${queryValues.length}`);
    }

    if (hasEquity) {
      whereClause.push(`equity > 0`);
    }

    const whereClauseStr = whereClause.length > 0 ? `WHERE ${whereClause.join(' AND ')}` : '';
    const query = `
      SELECT id, title, salary, equity, company_handle AS "companyHandle"
      FROM jobs
      ${whereClauseStr}
    `;
    const result = await db.query(query, queryValues); 

    console.log('Fetched jobs:', result.rows);

    if (result.rows.length === 0) {
      throw new NotFoundError(`No job found with the given parameters`);
    }
    
    return result.rows;
  }

  /** Given a job id, return data about job.
   *
   * Returns { id, title, salary, equity, company }
   *   where company is { handle, name, description, numEmployees, logoUrl }
   *
   * Throws NotFoundError if not found.
   **/

  static async get(id) {
    const jobRes = await db.query(
      `SELECT id, title, salary, equity, company_handle AS "companyHandle"
           FROM jobs
           WHERE id = $1`,
      [id]
    );
  
    const job = jobRes.rows[0];
  
    if (!job) throw new NotFoundError(`No job: ${id}`);
  
    const companyRes = await db.query(
      `SELECT handle, name, description, num_employees AS "numEmployees", logo_url AS "logoUrl"
           FROM companies
           WHERE handle = $1`,
      [job.companyHandle]
    );
  
    job.company = companyRes.rows[0];
  
    delete job.companyHandle;
  
    return job;
  }
  

  /** Update job data with `data`.
   *
   * This is a "partial update" --- it's fine if data doesn't contain all the
   * fields; this only changes provided ones.
   *
   * Data can include: {title, salary, equity}
   *
   * Returns {id, title, salary, equity, company_handle}
   *
   * Throws NotFoundError if not found.
   */

  static async update(id, data) {
    const { setCols, values } = sqlForPartialUpdate(
        data,
        {});
    const idVarIdx = "$" + (values.length + 1);

    const querySql = `UPDATE jobs 
                      SET ${setCols} 
                      WHERE id = ${idVarIdx} 
                      RETURNING id, 
                                title, 
                                salary, 
                                equity, 
                                company_handle`;
    const result = await db.query(querySql, [...values, id]);
    const job = result.rows[0];

    if (!job) throw new NotFoundError(`No job: ${id}`);

    return job;
  }

  /** Delete given job from database; returns undefined.
 *
 * Throws NotFoundError if job not found.
 **/

  static async remove(id) {
    const result = await db.query(
          `DELETE
            FROM jobs
            WHERE id = $1
            RETURNING id`,
        [id]);
    const job = result.rows[0];
    console.log(id)
    if (!job) throw new NotFoundError(`No job: ${id}`);
  }
}

module.exports = Job;

******************
Part 4 Commit 17:
****************** 
Test models/job.js in node repl:
create:
const newJob = await Job.create({ title: 'Software Engineer', salary: 80000, equity: 0.05, companyHandle: 'bauer-gallagher' });
console.log(newJob);

findAll:
const allJobs = await Job.findAll();
console.log(allJobs);

findAll/id:
const job = await Job.get(201); (200 is currently the last job in the database, so in these test the id of the created job is 201.)
console.log(job);

update:
const updatedJob = await Job.update(201, { title: 'Senior Software Engineer', salary: 90000 });  
console.log(updatedJob);

remove:
await Job.remove(201);  
console.log('Job removed');

******************
Part 4 Commit 18:
****************** 
Create routes/jobs.js:
"use strict";

const jsonschema = require("jsonschema");
const express = require("express");

const { BadRequestError } = require("../expressError");
const { ensureLoggedIn, authenticateJWT, ensureAdmin } = require("../middleware/auth");
const Job = require("../models/job");

const jobNewSchema = require("../schemas/jobNew.json");
const jobUpdateSchema = require("../schemas/jobUpdate.json");

const router = new express.Router();

/** POST / { job } =>  { job }
 *
 * job should be { title, salary, equity, companyHandle }
 *
 * Returns { id, title, salary, equity, companyHandle }
 *
 * Authorization required: login, admin
 */

router.post("/", ensureLoggedIn, authenticateJWT, ensureAdmin, async function (req, res, next) {
  try {
    const validator = jsonschema.validate(req.body, jobNewSchema);
    if (!validator.valid) {
      const errs = validator.errors.map(e => e.stack);
      throw new BadRequestError(errs);
    }

    const job = await Job.create(req.body);
    return res.status(201).json({ job });
  } catch (err) {
    return next(err);
  }
});

/** GET /  =>
 *   { jobs: [ { id, title, salary, equity, companyHandle }, ...] }
 *
 * Can filter on provided search filters:
 * - title
 * - minSalary
 * - hasEquity
 *
 * Authorization required: none
 */

router.get("/", async function (req, res, next) {
  console.log("Inside GET /jobs route handler"); 
  try {
    const jobs = await Job.findAll(req.query);
    return res.json({ jobs });
  } catch (err) {
    return next(err);
  }
});

/** GET /[id]  =>  { job }
 *
 *  Job is { id, title, salary, equity, company }
 *   where company is { handle, name, description, numEmployees, logoUrl }
 *
 * Authorization required: none
 */

router.get("/:id", async function (req, res, next) {
  try {
    const job = await Job.get(req.params.id);
    return res.json({ job });
  } catch (err) {
    return next(err);
  }
});

/** PATCH /[id] { fld1, fld2, ... } => { job }
 *
 * Patches job data.
 *
 * fields can be: { title, salary, equity }
 *
 * Returns { id, title, salary, equity, companyHandle }
 *
 * Authorization required: login, admin
 */

router.patch("/:id", ensureLoggedIn, authenticateJWT, ensureAdmin, async function (req, res, next) {
  try {
    const validator = jsonschema.validate(req.body, jobUpdateSchema);
    if (!validator.valid) {
      const errs = validator.errors.map(e => e.stack);
      throw new BadRequestError(errs);
    }

    const job = await Job.update(req.params.id, req.body);
    return res.json({ job });
  } catch (err) {
    return next(err);
  }
});

/** DELETE /[id]  =>  { deleted: id }
 *
 * Authorization: login, admin
 */

router.delete("/:id", ensureLoggedIn, authenticateJWT, ensureAdmin, async function (req, res, next) {
  try {
    await Job.remove(req.params.id);
    return res.json({ deleted: req.params.id });
  } catch (err) {
    return next(err);
  }
});

module.exports = router;

******************
Part 4 Commit 19:
****************** 
Write jobNew.json:
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "http://our.company.com/jobNew.schema.json",
  "type": "object",
  "properties": {
    "title": {
      "type": "string",
      "minLength": 1
    },
    "salary": {
      "type": "integer",
      "minimum": 0
    },
    "equity": {
      "type": "number",
      "minimum": 0,
      "maximum": 1
    },
    "companyHandle": {
      "type": "string",
      "minLength": 1,
      "maxLength": 25
    }
  },
  "additionalProperties": false,
  "required": ["title", "salary", "equity", "companyHandle"]
}

******************
Part 4 Commit 20:
****************** 
Write jobUpdate.json:
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "http://our.company.com/jobUpdate.schema.json",
  "type": "object",
  "properties": {
    "title": {
      "type": "string",
      "minLength": 1
    },
    "salary": {
      "type": "integer",
      "minimum": 0
    },
    "equity": {
      "type": "number",
      "minimum": 0,
      "maximum": 1
    }
  },
  "additionalProperties": false,
  "required": []
}

******************
Part 4 Commit 21:
****************** 
Import routes/jobs to app.js:
const jobsRoutes = require("./routes/jobs") 
...
app.use("/jobs", jobsRoutes);

******************
Part 4 Commit 22:
****************** 
Update _testCommon.js to reset jobs:
  // noinspection SqlWithoutWhere
  await db.query("DELETE FROM jobs");
  await db.query(`ALTER SEQUENCE jobs_id_seq RESTART WITH 1`);

Update INSERTs to include jobs:
  await db.query(`
      INSERT INTO jobs (title, salary, equity, company_handle)
      VALUES ('Job1', 10000, 0.1, 'c1'),
              ('Job2', 20000, 0.2, 'c2'),
              ('Job3', 30000, NULL, 'c3')
      `);

    const jobsResult = await db.query("SELECT * FROM jobs"); 
    
Test routes with cURL statements:
Login an admin:
curl -X POST "http://localhost:3001/auth/login" -H "Content-Type: application/json" -d '{"username": "11111", "password": "11111"}'
{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IjExMTExIiwiaXNBZG1pbiI6dHJ1ZSwiaWF0IjoxNjgyNzcxMDAwfQ.tML3LRd_etBparPfM0MJzVaU8SW8B_4ELjL9vAxvxBE"}

1. POST /jobs (create a new job): 
curl -X POST -H "Content-Type: application/json" -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IjExMTExIiwiaXNBZG1pbiI6dHJ1ZSwiaWF0IjoxNjgyNzcxMDAwfQ.tML3LRd_etBparPfM0MJzVaU8SW8B_4ELjL9vAxvxBE" -d '{"title": "Software Engineer", "salary": 90000, "equity": 0.05, "companyHandle": "hall-mills"}' http://localhost:3001/jobs

2. GET /jobs (retrieve all jobs): 
curl -X GET -H "Content-Type: application/json" http://localhost:3001/jobs 

3. GET /jobs/:id
curl "http://localhost:3001/jobs/202" 
(id 201 was used when testing the model)

4. PATCH /jobs/:id (update a specific job): 
curl -X PATCH -H "Content-Type: application/json" -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IjExMTExIiwiaXNBZG1pbiI6dHJ1ZSwiaWF0IjoxNjgyNzcxMDAwfQ.tML3LRd_etBparPfM0MJzVaU8SW8B_4ELjL9vAxvxBE" -d '{"title": "Senior Software Engineer", "salary": 95000}' http://localhost:3001/jobs/1

5. DELETE /jobs/:id (delete a specific job): 
curl -X DELETE -H "Content-Type: application/json" -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IjExMTExIiwiaXNBZG1pbiI6dHJ1ZSwiaWF0IjoxNjgyNzcxMDAwfQ.tML3LRd_etBparPfM0MJzVaU8SW8B_4ELjL9vAxvxBE" http://localhost:3001/jobs/202

******************
Part 4 Commit 23:
****************** 
Write models/job.test.js:
"use strict";

const db = require("../db.js");
const { BadRequestError, NotFoundError } = require("../expressError");
const Job = require("./job.js");
const {
  commonBeforeAll,
  commonBeforeEach,
  commonAfterEach,
  commonAfterAll,
} = require("./_testCommon");

beforeAll(commonBeforeAll);
beforeEach(commonBeforeEach);
afterEach(commonAfterEach);
afterAll(commonAfterAll);

/************************************** create */

describe("create", function () {
  const newJob = {
    title: "new",
    salary: 100000,
    equity: 0.5,
    companyHandle: "c1",
  };

  test("works", async function () {
    let job = await Job.create(newJob);

    job.equity = parseFloat(job.equity);

    expect(job).toEqual({ id: expect.any(Number), ...newJob });

    const result = await db.query(
          `SELECT id, title, salary, equity, company_handle AS "companyHandle"
           FROM jobs
           WHERE title = 'new'`);

    result.rows[0].equity = parseFloat(result.rows[0].equity);

    expect(result.rows).toEqual([
      {
        id: expect.any(Number),
        title: "new",
        salary: 100000,
        equity: 0.5,
        companyHandle: "c1",
      },
    ]);
  });

  test("bad request with invalid companyHandle", async function () {
    try {
      await Job.create({ title: "new", salary: 100000, equity: "0.5", companyHandle: "nope" });
      fail();
    } catch (err) {
      expect(err instanceof BadRequestError).toBeTruthy();
    }
  });
});

/************************************** findAll */

describe("findAll", function () {
  test("works: returns all jobs", async function () {
    const res = await Job.findAll({});
      expect(res).toEqual([
        {
          id: expect.any(Number),
          title: "Job1",
          salary: 10000,
          equity: "0.1",
          companyHandle: "c1",
        },
        {
          id: expect.any(Number),
          title: "Job2",
          salary: 20000,
          equity: "0.2",
          companyHandle: "c2",
        },
        {
          id: expect.any(Number),
          title: "Job3",
          salary: 30000,
          equity: null,
          companyHandle: "c3",
        },
      ]);
    });
  });

  test("works: filters by title", async function () {
    const res = await Job.findAll({ title: "1" });
    expect(res).toEqual([
      {
        id: expect.any(Number),
        title: "Job1",
        salary: 10000,
        equity: "0.1",
        companyHandle: "c1",
      },
    ]);
  });

  test("works: filters by minSalary", async function () {
    const res = await Job.findAll({ minSalary: 20000 });
    expect(res).toEqual([
      {
        id: expect.any(Number),
        title: "Job2",
        salary: 20000,
        equity: "0.2",
        companyHandle: "c2",
      },
      {
        id: expect.any(Number),
        title: "Job3",
        salary: 30000,
        equity: null,
        companyHandle: "c3",
      },
    ]);
  });

  test("works: filters by hasEquity", async function () {
    const res = await Job.findAll({ hasEquity: true });
    expect(res).toEqual([
      {
        id: expect.any(Number),
        title: "Job1",
        salary: 10000,
        equity: "0.1",
        companyHandle: "c1",
      },
      {
        id: expect.any(Number),
        title: "Job2",
        salary: 20000,
        equity: "0.2",
        companyHandle: "c2",
      },
    ]); 
  });

/************************************** update */

describe("update", function () {
  const updateData = {
    title: "New",
    salary: 200000,
    equity: "0.2",
  };

  test("works", async function () {
    const job = await Job.create({
      title: "Job1",
      salary: 10000,
      equity: 0.1,
      companyHandle: "c1",
    });
    
    let updatedJob = await Job.update(job.id, updateData);
    
    expect(updatedJob).toEqual({
      id: job.id,
      company_handle: "c1",
      ...updateData,
    });
  
    const result = await db.query(
      `SELECT id, company_handle, title, salary, equity
       FROM jobs
       WHERE id = $1`, [job.id]);
    
    expect(result.rows).toEqual([{
      id: job.id,
      company_handle: "c1",
      title: "New",
      salary: 200000,
      equity: "0.2",
    }]);
  });

  test("updates job with null fields", async function () {
    const updateData = {
      salary: null,
      equity: null,
    };
    const job = await Job.create({
      title: "Job1",
      salary: 10000,
      equity: 0.1,
      companyHandle: "c1",
    });
    const updatedJob = await Job.update(job.id, updateData);
    expect(updatedJob).toEqual({
      id: job.id,
      company_handle: "c1",
      title: "Job1",
      salary: null,
      equity: null,
    });
  });
  
  test("not found if no such job", async function () {
    try {
      await Job.update(9999, { title: "New", salary: 200000, equity: "0.2" });
    } catch (err) {
      expect(err instanceof NotFoundError).toBeTruthy();
      expect(err.message).toEqual("No job: 9999");
    }
  }); 

  test("bad request with no data", async function () {
    try {
      await Job.update("Job1", {}); 
    } catch (err) {
      expect(err instanceof BadRequestError).toBeTruthy();
    }
  });
});

/************************************** remove */

describe("remove", function () {
  test("works", async function () {
    await Job.remove(1);
    const res = await db.query(
        "DELETE FROM jobs WHERE id=1 ");
    expect(res.rows.length).toEqual(0);
  });

  test("not found if no such job", async function () {
    try {
      await Job.remove(10000); 
    } catch (err) {
      expect(err instanceof NotFoundError).toBeTruthy();
    }
  });
});

******************
Part 4 Commit 24:
****************** 
write routes/jobs.test.js:
"use strict";

const jsonschema = require("jsonschema");
const express = require("express");

const { BadRequestError } = require("../expressError");
const { ensureLoggedIn, authenticateJWT, ensureAdmin } = require("../middleware/auth");
const Job = require("../models/job");

const jobNewSchema = require("../schemas/jobNew.json");
const jobUpdateSchema = require("../schemas/jobUpdate.json");

const router = new express.Router();

/** POST / { job } =>  { job }
 *
 * job should be { title, salary, equity, companyHandle }
 *
 * Returns { id, title, salary, equity, companyHandle }
 *
 * Authorization required: login, admin
 */

router.post("/", ensureLoggedIn, authenticateJWT, ensureAdmin, async function (req, res, next) {
  try {
    const validator = jsonschema.validate(req.body, jobNewSchema);
    if (!validator.valid) {
      const errs = validator.errors.map(e => e.stack);
      throw new BadRequestError(errs);
    }

    const job = await Job.create(req.body);
    return res.status(201).json({ job });
  } catch (err) {
    return next(err);
  }
});

/** GET /  =>
 *   { jobs: [ { id, title, salary, equity, companyHandle }, ...] }
 *
 * Can filter on provided search filters:
 * - title
 * - minSalary
 * - hasEquity
 *
 * Authorization required: none
 */

router.get("/", async function (req, res, next) {
  console.log("Inside GET /jobs route handler"); 
  try {
    const jobs = await Job.findAll(req.query);
    return res.json({ jobs });
  } catch (err) {
    return next(err);
  }
});

/** GET /[id]  =>  { job }
 *
 *  Job is { id, title, salary, equity, company }
 *   where company is { handle, name, description, numEmployees, logoUrl }
 *
 * Authorization required: none
 */

router.get("/:id", async function (req, res, next) {
  try {
    const job = await Job.get(req.params.id);
    return res.json({ job });
  } catch (err) {
    return next(err);
  }
});

/** PATCH /[id] { fld1, fld2, ... } => { job }
 *
 * Patches job data.
 *
 * fields can be: { title, salary, equity }
 *
 * Returns { id, title, salary, equity, companyHandle }
 *
 * Authorization required: login, admin
 */

router.patch("/:id", ensureLoggedIn, authenticateJWT, ensureAdmin, async function (req, res, next) {
  try {
    const validator = jsonschema.validate(req.body, jobUpdateSchema);
    if (!validator.valid) {
      const errs = validator.errors.map(e => e.stack);
      throw new BadRequestError(errs);
    }

    const job = await Job.update(req.params.id, req.body);
    return res.json({ job });
  } catch (err) {
    return next(err);
  }
});

/** DELETE /[id]  =>  { deleted: id }
 *
 * Authorization: login, admin
 */

router.delete("/:id", ensureLoggedIn, authenticateJWT, ensureAdmin, async function (req, res, next) {
  try {
    await Job.remove(req.params.id);
    return res.json({ deleted: req.params.id });
  } catch (err) {
    return next(err);
  }
});

module.exports = router;

******************
Part 4 Commit 25:
****************** 
Update routes: companies.js GET /:handle:
/** GET /[handle]  =>  { company }
 *
 *  Company is { handle, name, description, numEmployees, logoUrl, jobs }
 *   where jobs is [{ id, title, salary, equity }, ...]
 *
 * Authorization required: none
 */

router.get("/:handle", async function (req, res, next) {
  try {
    const company = await Company.get(req.params.handle);
    console.log(company)
    return res.json({ company });

  } catch (err) {
    return next(err);
  }
});

Update tests for GET /companies/:handle:

/************************************** GET /companies/:handle */

describe("GET /companies/:handle", function () { 
  test("works for anon", async function () {
    const resp = await request(app).get(`/companies/c1`);
    expect(resp.body).toEqual({
      company: {
        handle: "c1",
        name: "C1",
        description: "Desc1",
        num_employees: 1,
        logo_url: "http://c1.img",
        jobs: [ 
          {
            "equity": "0.1",
            "id": 1,
            "salary": 10000,
            "title": "Job1",
          },
          {
            "equity": "0.2",
            "id": 2,
            "salary": 20000,
            "title": "Job2",
          },
          {
            "equity": null,
            "id": 3,
            "salary": 30000,
            "title": "Job3",
          },
        ],
      },
    });
  });
});

  test("works for anon: company w/o jobs", async function () {
    const resp = await request(app).get(`/companies/c2`);
    expect(resp.body).toEqual({
      company: {
        handle: "c2",
        name: "C2",
        description: "Desc2",
        num_employees: 2,
        logo_url: "http://c2.img",
        jobs: [],
      },
    });
  });

  test("not found for no such company", async function () {
    const resp = await request(app).get(`/companies/nope`);
    expect(resp.statusCode).toEqual(404);
  }); 

Documentation for the Job findAll function with filtering:

Description
An asynchronous method that searches for and retrieves job records from the jobs table in the database using provided search parameters. 
The function returns an array of found job records or throws a NotFoundError if no records match the given criteria.

Parameters
searchParams (Object, optional): An object containing key-value pairs of search criteria with a default value of an empty object ({}).
title (string, optional): case-insensitive and matches any title containing the provided string
minSalary (number, optional): only jobs with salaries greater than or equal to this value will be returned.
hasEquity (boolean, optional): A flag indicating whether or not to filter the results based on equity. If set to true, only jobs with positive equity values will be returned.

Returns
(Promise<Array<Object>>): A Promise that resolves to an array of job objects containing the following properties:

id (number): unique job identifier
title (string): title of the job.
salary (number): the salary offered 
equity (number): equity offered, represented as a decimal (e.g., 0.01 for 1%)
companyHandle (string): The unique identifier of the offering company  

Throws
NotFoundError: if no matching jobs are found 

******************
Part 5 Commit 26:
****************** 
Add apply() method to user model in models/user.js:
  /** Add a job application for the user with the provided username to the jobs table. 
   
  Parameters:
    jobId: the ID of the job being applied for
    username: the username of the user applying for the job
  Returns: { applied: jobId }

  Throws NotFoundError if the user or job is not found.

  Throws BadRequestError if the user has already applied for the job.
  **/

  static async apply(username, jobId, req) { 
    if (req.res.locals.user.username !== username && !req.res.locals.user.isAdmin) {
      throw new BadRequestError("You are not allowed to apply for other users unless you are an admin");
    }

    const preCheckRes = await db.query(
      `SELECT id, title, salary, equity, company_handle
      FROM jobs
      WHERE id = $1`, [jobId]);
    const job = preCheckRes.rows[0];
    if (!job) {
      throw new NotFoundError(`No job found with id ${jobId}`);
    }
  
    const checkRes = await db.query(
      `SELECT *
       FROM applications
       WHERE username = $1 AND job_id = $2`, [username, jobId]);
    if (checkRes.rows[0]) {
      throw new BadRequestError(`User ${username} has already applied to job ${jobId}`);
    }
  
    const result = await db.query(
      `INSERT INTO applications
       (username, job_id)
       VALUES ($1, $2)
       RETURNING job_id AS "jobId"`,
      [username, jobId]);
  
    const application = result.rows[0];
    return application.jobId;
  }

******************
Part 5 Commit 27:
****************** 
Add route for applying for a job in users.js:
/** POST /users/:username/jobs/:id => { applied: jobId }
*
* Allows a user to apply for a job with the given jobId.
*
* Returns JSON with key "applied" and the value of the jobId for which the user applied.
* 
* Authorization required: login
**/

router.post("/:username/jobs/:id", ensureLoggedIn, authenticateJWT, async function (req, res, next) {
  try {  
    const { username, id } = req.params;

    await User.apply(username, id, req);

    return res.json({ applied: id });
  } catch (err) {
    return next(err);
  }
});

******************
Part 5 Commit 28:
****************** 
Add tests in users.test.js for "apply" function in users.js:
/************************************** apply */
describe("apply", function () {
  test("user can apply for themselves", async () => {
    const jobId = 1; // Replace with an existing jobId in your test database
    const username = "u2";
    await expect(User.apply(username, jobId, { res: { locals: { user: { username: username, isAdmin: false }}}}))
      .resolves.toBe(jobId);
    });


  test("user cannot apply for anyone else", async () => {
    const jobId = 2; // Replace with an existing jobId in your test database
    const username = "u3";
    await expect(User.apply(username, jobId, { res: { locals: { user: { username: "u2", isAdmin: false }}}}))
      .rejects.toThrow(BadRequestError);
  });

  test("admin can apply for anyone", async () => {
    const jobId = 3; // Replace with an existing jobId in your test database
    const username = "u2";
    await expect(User.apply(username, jobId, { res: { locals: { user: { username: "u1", isAdmin: true }}}}))
      .resolves.toBe(jobId);
  });

  test("error thrown if job not found", async () => {
    const jobId = 9999; // Replace with a non-existent jobId
    const username = "u2";
    await expect(User.apply(username, jobId, { res: { locals: { user: { username: username, isAdmin: false }}}}))
      .rejects.toThrow(NotFoundError);
  }); 

  test("error thrown if param username has already applied for job", async () => {
    const jobId = 3; // Replace with an existing jobId in your test database that the user has already applied for
    const username = "u2";
    await User.apply(username, jobId, { res: { locals: { user: { username: username, isAdmin: false }}}}); // First apply
    await expect(User.apply(username, jobId, { res: { locals: { user: { username: username, isAdmin: false }}}}))
      .rejects.toThrow(BadRequestError);
  });
});

Note that the logic for returning the jobs array is in the user model. Without changing the route, if we curl:
curl -X GET -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6IjExMTExIiwiaXNBZG1pbiI6dHJ1ZSwiaWF0IjoxNjgzMDIzNTQ0fQ.fSjsfeAuYNWshYi93AA94oVUVdShzm_eVIXcIMZlu4Q" http://localhost:3001/users/11111

We get the user with the newly formed jobs array (here with ids 1, 6, 7):
{"user":{"username":"11111","firstName":"11111","lastName":"11111","email":"11111@11111.com","isAdmin":true,"jobs":[1,6,7]}}